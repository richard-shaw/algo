/* Generated by powerful Codeforces Tool
 * Author: RichardShaw
 * Time: 2021-09-30 17:34:29
 */
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
void fast_stream() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}
#define int long long
#define max(a, b) (a < b ? b : a)
const int INF = 0x7fffffffffffffff;
const int MAXN = 2e5 + 9;
int arr[MAXN], N, S = 0;
inline int find(int x) {
    return lower_bound(arr, arr + N, x) - arr;
}
void solve () {
    // 假设(a, S - a) <==> (x, y)
    // Ans = max(0, x - a) + max(0, a - (S - y))
    /*
     假设选择a，那么Ans = max(0, x - a) + max(0, a - (S - y))
     1. x+y=S
        1.1 x < a: Ans = a - (S-y) 求a 大于x的最小值
        1.2 x >= a: Ans = x - a, 求a 小于等于x的最大值
     2. x+y<S: 间隔点为(x, S-y)
        2.1 a < x: Ans = x - a 求a 小于x的最大值
        2.2 x < a < S-y: Ans = 0 + 0 = 0 任意值
        2.3 S-y < a: Ans = 0 + a - (S-y) 求a大于S-y的最大值
     3. x+y>S: 间隔点为(S-y, x)
        2.1 a < S-y; Ans = x - a, 求a 小于S-y的最大值
        2.2 S-y < a < x: Ans = x - a + a - S + y = x+y-S;
        2.3 x < a : Ans = 0 + a - (S-y) 求a大于x的最小值

     */
    int x, y; cin >> x >> y;
    if (x+y == S) {
        int a1 = find(x);
        if (a1 < )
    } else if (x+y < S) {

    } else {

    }
}

signed main() {
    fast_stream();
    cin >> N;
    for (int i = 0; i < N; i++) cin >> arr[i], S += arr[i];
    sort(arr, arr+N);
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}