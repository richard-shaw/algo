/* Generated by powerful Codeforces Tool
 * Author: RichardShaw
 * Time: 2021-12-22 17:04:07
 */
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
void fast_stream() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}
#define int long long
const int INF = 0x7fffffffffffffff;
const int MAXN = 2e5 + 9;
struct Mine {
    int timer, x, y, id;
} mines[MAXN];
inline bool cmp_row(Mine &a, Mine &b) {
    return a.y < b.y;
}
inline bool cmp_col(Mine &a, Mine &b) {
    return a.x < b.x;
}
int N, K, fa[MAXN], timer[MAXN], C;
map<int, vector<Mine>> row_mines;
map<int, vector<Mine>> col_mines;

int get_fa(int x) {
    if (fa[x] == x) return x;
    else return fa[x] = get_fa(fa[x]);
}
void _union(int x, int y) {
    int fx = get_fa(x), fy = get_fa(y);
    if (fx != fy) fa[fx] = fy;
}

void union_mines() {
    for (int i = 1; i <= N; i++) fa[i] = i;
    row_mines.clear();
    col_mines.clear();
    for (int i = 1; i <= N; i++) {
        auto row_iter = row_mines.find(mines[i].x), col_iter = col_mines.find(mines[i].y);
        if (row_iter != row_mines.end()) { vector<Mine> vec; vec.clear(); row_mines.insert(make_pair(mines[i].x, vec));}
        if (col_iter != col_mines.end()) { vector<Mine> vec; vec.clear(); col_mines.insert(make_pair(mines[i].y, vec));}
        row_mines[mines[i].x].push_back(mines[i]);
        col_mines[mines[i].y].push_back(mines[i]);
    }
    for (auto iter = row_mines.begin(); iter != row_mines.end(); ++iter) {
        sort(iter->second.begin(), iter->second.end(), cmp_row);
    }
    for (auto iter = col_mines.begin(); iter != col_mines.end(); ++iter) {
        sort(iter->second.begin(), iter->second.end(), cmp_col);
    }

    for (auto iter = row_mines.begin(); iter != row_mines.end(); ++iter) {
        for (int i = 0; i < iter->second.size()-1; i++) {
            int y1 = iter->second[i].y, y2 = iter->second[i+1].y;
            if (abs(y2-y1) <= K) _union(iter->second[i].id, iter->second[i+1].id);
        }
    }

    for (auto iter = col_mines.begin(); iter != col_mines.end(); ++iter) {
        for (int i = 0; i < iter->second.size()-1; i++) {
            int x1 = iter->second[i].x, x2 = iter->second[i+1].x;
            if (abs(x2-x1) <= K) _union(iter->second[i].id, iter->second[i+1].id);
        }
    }

    for (int i = 1; i <= N; i++) timer[i] = INF;
    for (int i = 1; i <= N; i++) {
        int fa_id = get_fa(mines[i].id);
        timer[fa_id] = min(timer[fa_id], mines[i].timer);
    }
    sort(timer+1, timer+1+N);
    C = 0;
    for (int i = 1; i <= N; i++) {
        if (timer[i] < INF) C++;
        else break;
    }
}
void solve () {
    cin >> N >> K;
    for (int i = 1; i <= N; i++) cin >> mines[i].x >> mines[i].y >> mines[i].timer, mines[i].id = i;
    union_mines();

    int st = 1, ed = C, t;
    for (t = 0;; t++) {
        while (timer[st] <= t) st++;
        ed--;
        if (st > ed) break;
    }
    cout << t << endl;
}

signed main() {
    fast_stream();
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}