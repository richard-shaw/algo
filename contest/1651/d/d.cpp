/* Generated by powerful Codeforces Tool
 * Author: shaw
 * Time: 2022-03-10 22:35:01
 */
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
void fast_stream() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}
const int MAXN = 2e5 + 400;
const int MXR = 320;
vector<int> Y[MAXN];
pair<int, int> points[MAXN];
set<pair<int, int>> valid;
map<pair<int, int>, int> radius;
map<pair<int, int>, pair<int, int>> target;
int dx[] = {-1,0,0,1};
int dy[] = {0,-1,1,0};
signed main() {
    for (int i = 0; i < MAXN; i++) Y[i].clear();
    valid.clear();
    radius.clear();
    target.clear();
    fast_stream();
    int N;
    cin >> N;
    for (int i = 1; i <= N; i++) {
        int x, y;
        cin >> x >> y;
        points[i].first = x, points[i].second = y;
        valid.insert({x, y});
    }
    queue<pair<int, int>> Q;
    while (!Q.empty()) Q.pop();
    for (int i = 1; i <= N; i++) {
        bool ok = true;
        int x = points[i].first, y = points[i].second;
        for (int idx = 0; idx < 4; idx++) {
            if (valid.find({x+dx[idx], y+dy[idx]}) == valid.end()) {
                ok = false;
                target[{x, y}] = {x+dx[idx], y+dy[idx]};
                break;
            }
        }
        if (!ok) {
            Q.push({x, y});
            radius[{x, y}] = 1;
        }
    }

    while (!Q.empty()) {
        pair<int, int> tp = Q.front(); Q.pop();
        int x = tp.first, y = tp.second;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (valid.find({nx, ny}) == valid.end()) continue;
            if (radius[{nx, ny}] == 0) {
                radius[{nx, ny}] = radius[{x, y}]+1;
                target[{nx, ny}] = target[{x, y}];
                Q.push({nx, ny});
            }
        }
    }
    for (int i = 1; i <= N; i++) {
        int x = points[i].first, y = points[i].second;
        pair<int, int> tg = target[{x, y}];
        cout << tg.first << ' ' << tg.second << endl;
    }
}
