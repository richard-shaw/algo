/* Generated by powerful Codeforces Tool
 * Author: RichardShaw
 * Time: 2021-10-30 22:35:10
 */
#pragma GCC optimize("Ofast", "inline", "-ffast-math")
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
using namespace std;
void fast_stream() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}
#define int long long
const int INF = 1e13;
const int MAXN = 1e5 + 5;
struct R {
    int best, l;
    R(int best, int l): best(best), l(l) {}
    bool operator< (int pos) {
        return l < pos;
    }
    bool operator<= (int pos) {
        return l <= pos;
    }
};
int visit[MAXN], phi[MAXN], prime[MAXN], f[MAXN][20], Q[MAXN][320], P[MAXN][320];
vector<R> vec;
int c(int l, int r) {
    if (l > r) return INF;
    int ans = 0;
    for (int i = l; i <= r; ) {
        int j = min(r, r / (r / i));
        ans += (j - i + 1) * phi[r / i];
        i = j + 1;
    }
    return ans + (r - l + 1);
}
int dp(int n, int k) {
    if (k == 1) return c(1, n);
    if (k >= 17) return n;
    if ((1 << k) >= n) return n;
    return f[n][k];
}
void init() {
    fast_stream();
    memset(visit, 0, sizeof(visit));
    int tot = 0;
    phi[0] = phi[1] = 0;
    for (int i = 2; i < MAXN; i++) {
        if (visit[i] == 0) prime[++tot] = i, phi[i] = i - 1;
        for (int j = 1; j <= tot && i * prime[j] < MAXN; j++) {
            visit[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else {
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
            }
        }
    }
    for (int i = 1; i < MAXN; i++) phi[i] += phi[i-1];
    int N = 100000;
//    for (int R = 1; R <= N; R++) {
//        for (int i = 1; i <= R;) {
//            int j = min(R, R / (R / i));
//            Q[R][R / i]
//        }
//
//    }
    for (int n = 1; n <= N; n++) f[n][1] = c(1, n);
    for (int k = 2; k <= 16; k++) {
        vec.clear();
        vec.push_back({k-1, 1});
        for (int n = k; n <= N; n++) {
            int best = vec[lower_bound(vec.begin(), vec.end(), n) - vec.begin() - 1].best;
            f[n][k] = f[best][k-1] + c(best+1, n);
            int last_r = N;
            for (int idx = vec.size() - 1; idx >= 0; idx--) {
                int l_best = vec[idx].best, l = vec[idx].l, r = last_r;
                last_r = vec[idx].l;
                if (n < l && f[l_best][k-1] + c(l_best+1, l) >= f[n][k-1] + c(n+1, l)) vec.pop_back();
                else {
                    while (l < r) {
                        int mid = (l + r) >> 1;
                        if (mid <= n) { l = mid + 1; continue; }
                        int a = f[l_best][k-1], b = c(l_best+1, mid), c0 = f[n][k-1], d = c(n+1, mid);
                        if (f[l_best][k-1] + c(l_best+1, mid) >= f[n][k-1] + c(n+1, mid)) r = mid;
                        else l = mid + 1;
                    }
                    if (l + 1 < N) vec.push_back(R(n, l + 1));
                    break;
                }
            }
            if (vec.empty()) vec.push_back(R(n, 1));
        }
    }
}

signed main() {
    clock_t t1 = clock();
    init();
    clock_t t2 = clock();
    cout << (double)(t2-t1) / CLOCKS_PER_SEC << endl;
    int t, n, k;
    cin >> t;
    while (t--) {
        cin >> n >> k;
        cout << dp(n, k) << endl;
    }
}